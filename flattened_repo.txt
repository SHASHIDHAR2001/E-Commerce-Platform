<database-schema.sql>
-- =================================================================
-- E-Commerce Order Management System - Database Schema (PostgreSQL)
-- =================================================================

-- ========================================
-- INVENTORY SERVICE DATABASE SCHEMA
-- ========================================

-- Products Table
-- Stores product information with inventory tracking
CREATE TABLE IF NOT EXISTS products (
    id BIGSERIAL PRIMARY KEY,
    sku VARCHAR(255) NOT NULL UNIQUE,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    price NUMERIC(10,2) NOT NULL CHECK (price > 0),
    stock_quantity INTEGER NOT NULL DEFAULT 0 CHECK (stock_quantity >= 0),
    active BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    version BIGINT DEFAULT 0
);

-- Index for faster lookups by SKU
CREATE INDEX IF NOT EXISTS idx_products_sku ON products(sku);

-- Index for faster lookups by active status
CREATE INDEX IF NOT EXISTS idx_products_active ON products(active);

-- ========================================
-- ORDER SERVICE DATABASE SCHEMA
-- ========================================

-- Orders Table
-- Stores customer order information
CREATE TABLE IF NOT EXISTS orders (
    id BIGSERIAL PRIMARY KEY,
    customer_name VARCHAR(255) NOT NULL,
    customer_email VARCHAR(255) NOT NULL,
    shipping_address VARCHAR(255) NOT NULL,
    status VARCHAR(50) NOT NULL CHECK (status IN ('PENDING','CONFIRMED','SHIPPED','DELIVERED','CANCELLED')),
    total_amount NUMERIC(10,2) NOT NULL DEFAULT 0 CHECK (total_amount >= 0),
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Order Items Table
-- Stores individual items within an order
CREATE TABLE IF NOT EXISTS order_items (
    id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,
    product_name VARCHAR(255) NOT NULL,
    quantity INTEGER NOT NULL CHECK (quantity > 0),
    price NUMERIC(10,2) NOT NULL CHECK (price >= 0),
    subtotal NUMERIC(10,2) NOT NULL CHECK (subtotal >= 0),
    CONSTRAINT fk_order_items_order 
        FOREIGN KEY (order_id) 
        REFERENCES orders(id) 
        ON DELETE CASCADE
);

-- Indexes for faster queries
CREATE INDEX IF NOT EXISTS idx_orders_status ON orders(status);
CREATE INDEX IF NOT EXISTS idx_orders_customer_email ON orders(customer_email);
CREATE INDEX IF NOT EXISTS idx_orders_created_at ON orders(created_at);
CREATE INDEX IF NOT EXISTS idx_order_items_order_id ON order_items(order_id);
CREATE INDEX IF NOT EXISTS idx_order_items_product_id ON order_items(product_id);

-- ========================================
-- SAMPLE DATA FOR TESTING
-- ========================================

-- Insert sample products
INSERT INTO products (sku, name, description, price, stock_quantity, active) VALUES
('LAPTOP-001', 'MacBook Pro 16"', '16-inch MacBook Pro with M3 chip, 16GB RAM, 512GB SSD', 2499.99, 50, true),
('LAPTOP-002', 'Dell XPS 15', '15.6-inch Dell XPS with Intel i7, 32GB RAM, 1TB SSD', 1899.99, 75, true),
('MOUSE-001', 'Logitech MX Master 3', 'Ergonomic wireless mouse with USB-C charging', 99.99, 200, true),
('KEYBOARD-001', 'Keychron K2', 'Mechanical keyboard with RGB backlight', 79.99, 150, true),
('MONITOR-001', 'LG UltraWide 34"', '34-inch UltraWide monitor with 3440x1440 resolution', 599.99, 30, true)
ON CONFLICT (sku) DO NOTHING;

-- ========================================
-- DATABASE FUNCTIONS AND TRIGGERS
-- ========================================

-- Function to automatically update the updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for products table
DROP TRIGGER IF EXISTS update_products_updated_at ON products;
CREATE TRIGGER update_products_updated_at
    BEFORE UPDATE ON products
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Trigger for orders table
DROP TRIGGER IF EXISTS update_orders_updated_at ON orders;
CREATE TRIGGER update_orders_updated_at
    BEFORE UPDATE ON orders
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- ========================================
-- USEFUL QUERIES FOR MONITORING
-- ========================================

-- View to get order summary with item counts
CREATE OR REPLACE VIEW order_summary AS
SELECT 
    o.id,
    o.customer_name,
    o.customer_email,
    o.status,
    o.total_amount,
    COUNT(oi.id) as item_count,
    SUM(oi.quantity) as total_quantity,
    o.created_at,
    o.updated_at
FROM orders o
LEFT JOIN order_items oi ON o.id = oi.order_id
GROUP BY o.id, o.customer_name, o.customer_email, o.status, o.total_amount, o.created_at, o.updated_at;

-- View to get low stock products
CREATE OR REPLACE VIEW low_stock_products AS
SELECT 
    id,
    sku,
    name,
    price,
    stock_quantity,
    created_at,
    updated_at
FROM products
WHERE stock_quantity < 10 AND active = true
ORDER BY stock_quantity ASC;

-- ========================================
-- PERFORMANCE OPTIMIZATION
-- ========================================

-- Analyze tables to update statistics for query planner
ANALYZE products;
ANALYZE orders;
ANALYZE order_items;

-- ========================================
-- CLEANUP QUERIES (USE WITH CAUTION)
-- ========================================

-- Uncomment below to reset all data (WARNING: This will delete all data)
-- DELETE FROM order_items;
-- DELETE FROM orders;
-- DELETE FROM products;
-- ALTER SEQUENCE products_id_seq RESTART WITH 1;
-- ALTER SEQUENCE orders_id_seq RESTART WITH 1;
-- ALTER SEQUENCE order_items_id_seq RESTART WITH 1;

</database-schema.sql>

<docker-compose.yml>
version: '3.8'

services:
  rabbitmq:
    image: rabbitmq:3-management
    container_name: ecommerce-rabbitmq
    ports:
      - "5672:5672"
      - "15672:15672"
    environment:
      RABBITMQ_DEFAULT_USER: guest
      RABBITMQ_DEFAULT_PASS: guest
    healthcheck:
      test: ["CMD", "rabbitmq-diagnostics", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - ecommerce-network

networks:
  ecommerce-network:
    driver: bridge

</docker-compose.yml>

<inventory-service/pom.xml>
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
        <relativePath/>
    </parent>

    <groupId>com.ecommerce</groupId>
    <artifactId>inventory-service</artifactId>
    <version>1.0.0</version>
    <name>Inventory Service</name>
    <description>Inventory Management Microservice</description>

    <properties>
        <java.version>17</java.version>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-amqp</artifactId>
        </dependency>

        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>2.3.0</version>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>

</inventory-service/pom.xml>

<inventory-service/src/main/java/com/ecommerce/inventoryservice/config/OpenAPIConfig.java>
package com.ecommerce.inventoryservice.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.servers.Server;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.List;

@Configuration
public class OpenAPIConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("Inventory Service API")
                        .version("1.0.0")
                        .description("Inventory Management Microservice - Handles product management, stock control, and inventory operations")
                        .contact(new Contact()
                                .name("E-Commerce Platform")
                                .email("support@ecommerce.com")))
                .servers(List.of(
                        new Server().url("http://localhost:8000").description("Inventory Service")
                ));
    }
}

</inventory-service/src/main/java/com/ecommerce/inventoryservice/config/OpenAPIConfig.java>

<inventory-service/src/main/java/com/ecommerce/inventoryservice/config/RabbitMQConfig.java>
package com.ecommerce.inventoryservice.config;

import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.TopicExchange;
import org.springframework.amqp.rabbit.connection.ConnectionFactory;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;
import org.springframework.amqp.support.converter.MessageConverter;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RabbitMQConfig {

    @Value("${rabbitmq.queue.inventory}")
    private String inventoryQueue;

    @Value("${rabbitmq.exchange.inventory}")
    private String inventoryExchange;

    @Value("${rabbitmq.routing.key.inventory}")
    private String inventoryRoutingKey;

    @Bean
    public Queue inventoryQueue() {
        return new Queue(inventoryQueue, true);
    }

    @Bean
    public TopicExchange inventoryExchange() {
        return new TopicExchange(inventoryExchange);
    }

    @Bean
    public Binding inventoryBinding() {
        return BindingBuilder
                .bind(inventoryQueue())
                .to(inventoryExchange())
                .with(inventoryRoutingKey);
    }

    @Bean
    public MessageConverter messageConverter() {
        return new Jackson2JsonMessageConverter();
    }

    @Bean
    public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {
        RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory);
        rabbitTemplate.setMessageConverter(messageConverter());
        return rabbitTemplate;
    }
}

</inventory-service/src/main/java/com/ecommerce/inventoryservice/config/RabbitMQConfig.java>

<inventory-service/src/main/java/com/ecommerce/inventoryservice/controller/InventoryController.java>
package com.ecommerce.inventoryservice.controller;

import com.ecommerce.inventoryservice.dto.ProductRequest;
import com.ecommerce.inventoryservice.dto.ProductResponse;
import com.ecommerce.inventoryservice.dto.ReserveStockRequest;
import com.ecommerce.inventoryservice.dto.StockUpdateRequest;
import com.ecommerce.inventoryservice.service.InventoryService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/inventory")
@Tag(name = "Inventory Management", description = "APIs for managing products and inventory")
public class InventoryController {

    private static final Logger logger = LoggerFactory.getLogger(InventoryController.class);

    @Autowired
    private InventoryService inventoryService;

    @PostMapping("/products")
    @Operation(summary = "Create a new product", description = "Add a new product to the inventory")
    public ResponseEntity<ProductResponse> createProduct(@Valid @RequestBody ProductRequest request) {
        logger.info("REST request to create product: {}", request.getSku());
        ProductResponse response = inventoryService.createProduct(request);
        return new ResponseEntity<>(response, HttpStatus.CREATED);
    }

    @GetMapping("/products/{id}")
    @Operation(summary = "Get product by ID", description = "Retrieve product details by product ID")
    public ResponseEntity<ProductResponse> getProductById(@PathVariable Long id) {
        logger.info("REST request to get product: {}", id);
        ProductResponse response = inventoryService.getProductById(id);
        return ResponseEntity.ok(response);
    }

    @GetMapping("/products")
    @Operation(summary = "Get all products", description = "Retrieve all products in the inventory")
    public ResponseEntity<List<ProductResponse>> getAllProducts() {
        logger.info("REST request to get all products");
        List<ProductResponse> response = inventoryService.getAllProducts();
        return ResponseEntity.ok(response);
    }

    @GetMapping("/products/active")
    @Operation(summary = "Get active products", description = "Retrieve all active products")
    public ResponseEntity<List<ProductResponse>> getActiveProducts() {
        logger.info("REST request to get active products");
        List<ProductResponse> response = inventoryService.getActiveProducts();
        return ResponseEntity.ok(response);
    }

    @PutMapping("/products/{id}")
    @Operation(summary = "Update product", description = "Update an existing product")
    public ResponseEntity<ProductResponse> updateProduct(
            @PathVariable Long id, 
            @Valid @RequestBody ProductRequest request) {
        logger.info("REST request to update product: {}", id);
        ProductResponse response = inventoryService.updateProduct(id, request);
        return ResponseEntity.ok(response);
    }

    @DeleteMapping("/products/{id}")
    @Operation(summary = "Delete product", description = "Delete a product from inventory")
    public ResponseEntity<Map<String, String>> deleteProduct(@PathVariable Long id) {
        logger.info("REST request to delete product: {}", id);
        inventoryService.deleteProduct(id);
        Map<String, String> response = new HashMap<>();
        response.put("message", "Product deleted successfully");
        return ResponseEntity.ok(response);
    }

    @PostMapping("/products/{id}/add-stock")
    @Operation(summary = "Add stock", description = "Add stock quantity to a product")
    public ResponseEntity<ProductResponse> addStock(
            @PathVariable Long id, 
            @Valid @RequestBody StockUpdateRequest request) {
        logger.info("REST request to add stock to product: {}", id);
        ProductResponse response = inventoryService.addStock(id, request.getQuantity());
        return ResponseEntity.ok(response);
    }

    @PostMapping("/products/{id}/reduce-stock")
    @Operation(summary = "Reduce stock", description = "Reduce stock quantity from a product")
    public ResponseEntity<ProductResponse> reduceStock(
            @PathVariable Long id, 
            @Valid @RequestBody StockUpdateRequest request) {
        logger.info("REST request to reduce stock from product: {}", id);
        ProductResponse response = inventoryService.reduceStock(id, request.getQuantity());
        return ResponseEntity.ok(response);
    }

    @PostMapping("/reserve-stock")
    public ResponseEntity<String> reserveStock(@RequestBody ReserveStockRequest request) {

        inventoryService.reduceStock(request.getProductId(), request.getQuantity());

        return ResponseEntity.ok("Stock Reserved Successfully");
    }


    @GetMapping("/products/{id}/check-stock")
    @Operation(summary = "Check stock availability", description = "Check if sufficient stock is available")
    public ResponseEntity<Map<String, Boolean>> checkStock(
            @PathVariable Long id, 
            @RequestParam Integer quantity) {
        logger.info("REST request to check stock for product: {}", id);
        boolean available = inventoryService.checkStock(id, quantity);
        Map<String, Boolean> response = new HashMap<>();
        response.put("available", available);
        return ResponseEntity.ok(response);
    }
}

</inventory-service/src/main/java/com/ecommerce/inventoryservice/controller/InventoryController.java>

<inventory-service/src/main/java/com/ecommerce/inventoryservice/dto/ProductRequest.java>
package com.ecommerce.inventoryservice.dto;

import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProductRequest {

    @NotBlank(message = "SKU is required")
    private String sku;

    @NotBlank(message = "Product name is required")
    private String name;

    private String description;

    @NotNull(message = "Price is required")
    @DecimalMin(value = "0.0", inclusive = false, message = "Price must be greater than 0")
    private BigDecimal price;

    @NotNull(message = "Stock quantity is required")
    @Min(value = 0, message = "Stock quantity cannot be negative")
    private Integer stockQuantity;

    private Boolean active = true;
}

</inventory-service/src/main/java/com/ecommerce/inventoryservice/dto/ProductRequest.java>

<inventory-service/src/main/java/com/ecommerce/inventoryservice/dto/ProductResponse.java>
package com.ecommerce.inventoryservice.dto;

import com.ecommerce.inventoryservice.model.Product;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProductResponse {
    private Long id;
    private String sku;
    private String name;
    private String description;
    private BigDecimal price;
    private Integer stockQuantity;
    private Boolean active;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    public static ProductResponse fromEntity(Product product) {
        ProductResponse response = new ProductResponse();
        response.setId(product.getId());
        response.setSku(product.getSku());
        response.setName(product.getName());
        response.setDescription(product.getDescription());
        response.setPrice(product.getPrice());
        response.setStockQuantity(product.getStockQuantity());
        response.setActive(product.getActive());
        response.setCreatedAt(product.getCreatedAt());
        response.setUpdatedAt(product.getUpdatedAt());
        return response;
    }
}

</inventory-service/src/main/java/com/ecommerce/inventoryservice/dto/ProductResponse.java>

<inventory-service/src/main/java/com/ecommerce/inventoryservice/dto/ReserveStockRequest.java>
package com.ecommerce.inventoryservice.dto;

public class ReserveStockRequest {
    private Long productId;
    private Integer quantity;

    public ReserveStockRequest() {}

    public ReserveStockRequest(Long productId, Integer quantity) {
        this.productId = productId;
        this.quantity = quantity;
    }

    public Long getProductId() { return productId; }
    public Integer getQuantity() { return quantity; }
}

</inventory-service/src/main/java/com/ecommerce/inventoryservice/dto/ReserveStockRequest.java>

<inventory-service/src/main/java/com/ecommerce/inventoryservice/dto/StockUpdateRequest.java>
package com.ecommerce.inventoryservice.dto;

import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class StockUpdateRequest {

    @NotNull(message = "Quantity is required")
    private Integer quantity;
}

</inventory-service/src/main/java/com/ecommerce/inventoryservice/dto/StockUpdateRequest.java>

<inventory-service/src/main/java/com/ecommerce/inventoryservice/exception/DuplicateProductException.java>
package com.ecommerce.inventoryservice.exception;

public class DuplicateProductException extends RuntimeException {
    public DuplicateProductException(String message) {
        super(message);
    }
}

</inventory-service/src/main/java/com/ecommerce/inventoryservice/exception/DuplicateProductException.java>

<inventory-service/src/main/java/com/ecommerce/inventoryservice/exception/GlobalExceptionHandler.java>
package com.ecommerce.inventoryservice.exception;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    @ExceptionHandler(ProductNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleProductNotFound(ProductNotFoundException ex) {
        logger.error("Product not found: {}", ex.getMessage());
        ErrorResponse error = new ErrorResponse(
                HttpStatus.NOT_FOUND.value(),
                ex.getMessage(),
                LocalDateTime.now()
        );
        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(DuplicateProductException.class)
    public ResponseEntity<ErrorResponse> handleDuplicateProduct(DuplicateProductException ex) {
        logger.error("Duplicate product: {}", ex.getMessage());
        ErrorResponse error = new ErrorResponse(
                HttpStatus.CONFLICT.value(),
                ex.getMessage(),
                LocalDateTime.now()
        );
        return new ResponseEntity<>(error, HttpStatus.CONFLICT);
    }

    @ExceptionHandler(InsufficientStockException.class)
    public ResponseEntity<ErrorResponse> handleInsufficientStock(InsufficientStockException ex) {
        logger.error("Insufficient stock: {}", ex.getMessage());
        ErrorResponse error = new ErrorResponse(
                HttpStatus.BAD_REQUEST.value(),
                ex.getMessage(),
                LocalDateTime.now()
        );
        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ValidationErrorResponse> handleValidationErrors(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach(error -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });
        
        ValidationErrorResponse errorResponse = new ValidationErrorResponse(
                HttpStatus.BAD_REQUEST.value(),
                "Validation failed",
                errors,
                LocalDateTime.now()
        );
        logger.error("Validation errors: {}", errors);
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {
        logger.error("Unexpected error occurred: ", ex);
        ErrorResponse error = new ErrorResponse(
                HttpStatus.INTERNAL_SERVER_ERROR.value(),
                "An unexpected error occurred: " + ex.getMessage(),
                LocalDateTime.now()
        );
        return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}

class ErrorResponse {
    private int status;
    private String message;
    private LocalDateTime timestamp;

    public ErrorResponse(int status, String message, LocalDateTime timestamp) {
        this.status = status;
        this.message = message;
        this.timestamp = timestamp;
    }

    public int getStatus() { return status; }
    public void setStatus(int status) { this.status = status; }
    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }
    public LocalDateTime getTimestamp() { return timestamp; }
    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }
}

class ValidationErrorResponse {
    private int status;
    private String message;
    private Map<String, String> errors;
    private LocalDateTime timestamp;

    public ValidationErrorResponse(int status, String message, Map<String, String> errors, LocalDateTime timestamp) {
        this.status = status;
        this.message = message;
        this.errors = errors;
        this.timestamp = timestamp;
    }

    public int getStatus() { return status; }
    public void setStatus(int status) { this.status = status; }
    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }
    public Map<String, String> getErrors() { return errors; }
    public void setErrors(Map<String, String> errors) { this.errors = errors; }
    public LocalDateTime getTimestamp() { return timestamp; }
    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }
}

</inventory-service/src/main/java/com/ecommerce/inventoryservice/exception/GlobalExceptionHandler.java>

<inventory-service/src/main/java/com/ecommerce/inventoryservice/exception/InsufficientStockException.java>
package com.ecommerce.inventoryservice.exception;

public class InsufficientStockException extends RuntimeException {
    public InsufficientStockException(String message) {
        super(message);
    }
}

</inventory-service/src/main/java/com/ecommerce/inventoryservice/exception/InsufficientStockException.java>

<inventory-service/src/main/java/com/ecommerce/inventoryservice/exception/ProductNotFoundException.java>
package com.ecommerce.inventoryservice.exception;

public class ProductNotFoundException extends RuntimeException {
    public ProductNotFoundException(String message) {
        super(message);
    }
}

</inventory-service/src/main/java/com/ecommerce/inventoryservice/exception/ProductNotFoundException.java>

<inventory-service/src/main/java/com/ecommerce/inventoryservice/InventoryServiceApplication.java>
package com.ecommerce.inventoryservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class InventoryServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(InventoryServiceApplication.class, args);
    }
}

</inventory-service/src/main/java/com/ecommerce/inventoryservice/InventoryServiceApplication.java>

<inventory-service/src/main/java/com/ecommerce/inventoryservice/model/Product.java>
package com.ecommerce.inventoryservice.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@Entity
@Table(name = "products")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Product {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String sku;

    @Column(nullable = false)
    private String name;

    @Column(length = 1000)
    private String description;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal price;

    @Column(nullable = false)
    private Integer stockQuantity = 0;

    @Column(nullable = false)
    private Boolean active = true;

    @CreationTimestamp
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(nullable = false)
    private LocalDateTime updatedAt;

    @Version
    private Long version;
}

</inventory-service/src/main/java/com/ecommerce/inventoryservice/model/Product.java>

<inventory-service/src/main/java/com/ecommerce/inventoryservice/repository/ProductRepository.java>
package com.ecommerce.inventoryservice.repository;

import com.ecommerce.inventoryservice.model.Product;
import jakarta.persistence.LockModeType;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Lock;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    Optional<Product> findBySku(String sku);
    
    List<Product> findByActiveTrue();
    
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT p FROM Product p WHERE p.id = :id")
    Optional<Product> findByIdWithLock(@Param("id") Long id);
}

</inventory-service/src/main/java/com/ecommerce/inventoryservice/repository/ProductRepository.java>

<inventory-service/src/main/java/com/ecommerce/inventoryservice/service/InventoryMessageConsumer.java>
package com.ecommerce.inventoryservice.service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;

@Service
public class InventoryMessageConsumer {

    private static final Logger logger = LoggerFactory.getLogger(InventoryMessageConsumer.class);

    @Autowired
    private InventoryService inventoryService;

    @RabbitListener(queues = "${rabbitmq.queue.inventory}")
    public void consumeInventoryMessage(Map<String, Object> inventoryEvent) {
        logger.info("Received inventory event from queue");
        logger.info("Event details: {}", inventoryEvent);
        logger.info("Inventory processing completed successfully");
    }
}

</inventory-service/src/main/java/com/ecommerce/inventoryservice/service/InventoryMessageConsumer.java>

<inventory-service/src/main/java/com/ecommerce/inventoryservice/service/InventoryService.java>
package com.ecommerce.inventoryservice.service;

import com.ecommerce.inventoryservice.dto.ProductRequest;
import com.ecommerce.inventoryservice.dto.ProductResponse;
import com.ecommerce.inventoryservice.exception.DuplicateProductException;
import com.ecommerce.inventoryservice.exception.InsufficientStockException;
import com.ecommerce.inventoryservice.exception.ProductNotFoundException;
import com.ecommerce.inventoryservice.model.Product;
import com.ecommerce.inventoryservice.repository.ProductRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class InventoryService {

    private static final Logger logger = LoggerFactory.getLogger(InventoryService.class);

    @Autowired
    private ProductRepository productRepository;

    @Transactional
    public ProductResponse createProduct(ProductRequest request) {
        logger.info("Creating new product with SKU: {}", request.getSku());
        
        if (productRepository.findBySku(request.getSku()).isPresent()) {
            throw new DuplicateProductException("Product with SKU " + request.getSku() + " already exists");
        }

        Product product = new Product();
        product.setSku(request.getSku());
        product.setName(request.getName());
        product.setDescription(request.getDescription());
        product.setPrice(request.getPrice());
        product.setStockQuantity(request.getStockQuantity());
        product.setActive(request.getActive() != null ? request.getActive() : true);

        Product savedProduct = productRepository.save(product);
        logger.info("Product created successfully with ID: {}", savedProduct.getId());
        
        return ProductResponse.fromEntity(savedProduct);
    }

    public ProductResponse getProductById(Long id) {
        logger.info("Fetching product with ID: {}", id);
        Product product = productRepository.findById(id)
                .orElseThrow(() -> new ProductNotFoundException("Product not found with ID: " + id));
        return ProductResponse.fromEntity(product);
    }

    public List<ProductResponse> getAllProducts() {
        logger.info("Fetching all products");
        return productRepository.findAll().stream()
                .map(ProductResponse::fromEntity)
                .collect(Collectors.toList());
    }

    public List<ProductResponse> getActiveProducts() {
        logger.info("Fetching all active products");
        return productRepository.findByActiveTrue().stream()
                .map(ProductResponse::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional
    public ProductResponse updateProduct(Long id, ProductRequest request) {
        logger.info("Updating product with ID: {}", id);
        
        Product product = productRepository.findById(id)
                .orElseThrow(() -> new ProductNotFoundException("Product not found with ID: " + id));

        if (!product.getSku().equals(request.getSku())) {
            if (productRepository.findBySku(request.getSku()).isPresent()) {
                throw new DuplicateProductException("Product with SKU " + request.getSku() + " already exists");
            }
            product.setSku(request.getSku());
        }

        product.setName(request.getName());
        product.setDescription(request.getDescription());
        product.setPrice(request.getPrice());
        product.setStockQuantity(request.getStockQuantity());
        product.setActive(request.getActive());

        Product updatedProduct = productRepository.save(product);
        logger.info("Product updated successfully with ID: {}", updatedProduct.getId());
        
        return ProductResponse.fromEntity(updatedProduct);
    }

    @Transactional
    public void deleteProduct(Long id) {
        logger.info("Deleting product with ID: {}", id);
        
        Product product = productRepository.findById(id)
                .orElseThrow(() -> new ProductNotFoundException("Product not found with ID: " + id));
        
        productRepository.delete(product);
        logger.info("Product deleted successfully with ID: {}", id);
    }

    @Transactional
    public ProductResponse addStock(Long productId, Integer quantity) {
        logger.info("Adding {} units to product ID: {}", quantity, productId);
        
        Product product = productRepository.findByIdWithLock(productId)
                .orElseThrow(() -> new ProductNotFoundException("Product not found with ID: " + productId));

        product.setStockQuantity(product.getStockQuantity() + quantity);
        Product updatedProduct = productRepository.save(product);
        
        logger.info("Stock added successfully. New quantity: {}", updatedProduct.getStockQuantity());
        return ProductResponse.fromEntity(updatedProduct);
    }

    @Transactional
    public ProductResponse reduceStock(Long productId, Integer quantity) {
        logger.info("Reducing {} units from product ID: {}", quantity, productId);
        
        Product product = productRepository.findByIdWithLock(productId)
                .orElseThrow(() -> new ProductNotFoundException("Product not found with ID: " + productId));

        if (product.getStockQuantity() < quantity) {
            throw new InsufficientStockException(
                "Insufficient stock for product: " + product.getName() + 
                ". Available: " + product.getStockQuantity() + ", Requested: " + quantity
            );
        }

        product.setStockQuantity(product.getStockQuantity() - quantity);
        Product updatedProduct = productRepository.save(product);
        
        logger.info("Stock reduced successfully. New quantity: {}", updatedProduct.getStockQuantity());
        return ProductResponse.fromEntity(updatedProduct);
    }

    public boolean checkStock(Long productId, Integer quantity) {
        logger.info("Checking stock for product ID: {} with quantity: {}", productId, quantity);
        
        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new ProductNotFoundException("Product not found with ID: " + productId));

        boolean hasStock = product.getStockQuantity() >= quantity;
        logger.info("Stock check result: {}", hasStock);
        return hasStock;
    }
}

</inventory-service/src/main/java/com/ecommerce/inventoryservice/service/InventoryService.java>

<order-service/pom.xml>
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
        <relativePath/>
    </parent>

    <groupId>com.ecommerce</groupId>
    <artifactId>order-service</artifactId>
    <version>1.0.0</version>
    <name>Order Service</name>
    <description>Order Management Microservice</description>

    <properties>
        <java.version>17</java.version>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-amqp</artifactId>
        </dependency>

        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>2.3.0</version>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>

</order-service/pom.xml>

<order-service/src/main/java/com/ecommerce/orderservice/config/AppConfig.java>
package com.ecommerce.orderservice.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class AppConfig {

    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}

</order-service/src/main/java/com/ecommerce/orderservice/config/AppConfig.java>

<order-service/src/main/java/com/ecommerce/orderservice/config/OpenAPIConfig.java>
package com.ecommerce.orderservice.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.servers.Server;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.List;

@Configuration
public class OpenAPIConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("Order Service API")
                        .version("1.0.0")
                        .description("Order Management Microservice - Handles order placement, status updates, and order retrieval")
                        .contact(new Contact()
                                .name("E-Commerce Platform")
                                .email("support@ecommerce.com")))
                .servers(List.of(
                        new Server().url("http://localhost:8080").description("Order Service")
                ));
    }
}

</order-service/src/main/java/com/ecommerce/orderservice/config/OpenAPIConfig.java>

<order-service/src/main/java/com/ecommerce/orderservice/config/RabbitMQConfig.java>
package com.ecommerce.orderservice.config;

import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.TopicExchange;
import org.springframework.amqp.rabbit.connection.ConnectionFactory;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;
import org.springframework.amqp.support.converter.MessageConverter;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RabbitMQConfig {

    @Value("${rabbitmq.queue.order}")
    private String orderQueue;

    @Value("${rabbitmq.exchange.order}")
    private String orderExchange;

    @Value("${rabbitmq.routing.key.order}")
    private String orderRoutingKey;

    @Bean
    public Queue orderQueue() {
        return new Queue(orderQueue, true);
    }

    @Bean
    public TopicExchange orderExchange() {
        return new TopicExchange(orderExchange);
    }

    @Bean
    public Binding orderBinding() {
        return BindingBuilder
                .bind(orderQueue())
                .to(orderExchange())
                .with(orderRoutingKey);
    }

    @Bean
    public MessageConverter messageConverter() {
        return new Jackson2JsonMessageConverter();
    }

    @Bean
    public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {
        RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory);
        rabbitTemplate.setMessageConverter(messageConverter());
        return rabbitTemplate;
    }
}

</order-service/src/main/java/com/ecommerce/orderservice/config/RabbitMQConfig.java>

<order-service/src/main/java/com/ecommerce/orderservice/controller/OrderController.java>
package com.ecommerce.orderservice.controller;

import com.ecommerce.orderservice.dto.OrderRequest;
import com.ecommerce.orderservice.dto.OrderResponse;
import com.ecommerce.orderservice.dto.OrderStatusUpdateRequest;
import com.ecommerce.orderservice.model.OrderStatus;
import com.ecommerce.orderservice.service.OrderService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/orders")
@Tag(name = "Order Management", description = "APIs for managing orders")
public class OrderController {

    private static final Logger logger = LoggerFactory.getLogger(OrderController.class);

    @Autowired
    private OrderService orderService;

    @PostMapping
    @Operation(summary = "Create a new order", description = "Place a new order with inventory validation")
    public ResponseEntity<OrderResponse> createOrder(@Valid @RequestBody OrderRequest request) {
        logger.info("REST request to create order for: {}", request.getCustomerEmail());
        OrderResponse response = orderService.createOrder(request);
        return new ResponseEntity<>(response, HttpStatus.CREATED);
    }

    @GetMapping("/{id}")
    @Operation(summary = "Get order by ID", description = "Retrieve order details by order ID")
    public ResponseEntity<OrderResponse> getOrderById(@PathVariable Long id) {
        logger.info("REST request to get order: {}", id);
        OrderResponse response = orderService.getOrderById(id);
        return ResponseEntity.ok(response);
    }

    @GetMapping
    @Operation(summary = "Get all orders", description = "Retrieve all orders")
    public ResponseEntity<List<OrderResponse>> getAllOrders() {
        logger.info("REST request to get all orders");
        List<OrderResponse> response = orderService.getAllOrders();
        return ResponseEntity.ok(response);
    }

    @GetMapping("/status/{status}")
    @Operation(summary = "Get orders by status", description = "Retrieve orders by their status")
    public ResponseEntity<List<OrderResponse>> getOrdersByStatus(@PathVariable OrderStatus status) {
        logger.info("REST request to get orders by status: {}", status);
        List<OrderResponse> response = orderService.getOrdersByStatus(status);
        return ResponseEntity.ok(response);
    }

    @GetMapping("/customer/{email}")
    @Operation(summary = "Get orders by customer email", description = "Retrieve orders for a specific customer")
    public ResponseEntity<List<OrderResponse>> getOrdersByEmail(@PathVariable String email) {
        logger.info("REST request to get orders for email: {}", email);
        List<OrderResponse> response = orderService.getOrdersByEmail(email);
        return ResponseEntity.ok(response);
    }

    @PutMapping("/{id}/status")
    @Operation(summary = "Update order status", description = "Update the status of an existing order")
    public ResponseEntity<OrderResponse> updateOrderStatus(
            @PathVariable Long id, 
            @Valid @RequestBody OrderStatusUpdateRequest request) {
        logger.info("REST request to update order {} status to: {}", id, request.getStatus());
        OrderResponse response = orderService.updateOrderStatus(id, request.getStatus());
        return ResponseEntity.ok(response);
    }
}

</order-service/src/main/java/com/ecommerce/orderservice/controller/OrderController.java>

<order-service/src/main/java/com/ecommerce/orderservice/dto/OrderItemRequest.java>
package com.ecommerce.orderservice.dto;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderItemRequest {

    @NotNull(message = "Product ID is required")
    private Long productId;

    @NotNull(message = "Quantity is required")
    @Min(value = 1, message = "Quantity must be at least 1")
    private Integer quantity;
}

</order-service/src/main/java/com/ecommerce/orderservice/dto/OrderItemRequest.java>

<order-service/src/main/java/com/ecommerce/orderservice/dto/OrderRequest.java>
package com.ecommerce.orderservice.dto;

import jakarta.validation.Valid;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotEmpty;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderRequest {

    @NotBlank(message = "Customer name is required")
    private String customerName;

    @NotBlank(message = "Customer email is required")
    @Email(message = "Invalid email format")
    private String customerEmail;

    @NotBlank(message = "Shipping address is required")
    private String shippingAddress;

    @NotEmpty(message = "Order must contain at least one item")
    @Valid
    private List<OrderItemRequest> items;
}

</order-service/src/main/java/com/ecommerce/orderservice/dto/OrderRequest.java>

<order-service/src/main/java/com/ecommerce/orderservice/dto/OrderResponse.java>
package com.ecommerce.orderservice.dto;

import com.ecommerce.orderservice.model.Order;
import com.ecommerce.orderservice.model.OrderItem;
import com.ecommerce.orderservice.model.OrderStatus;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderResponse {
    private Long id;
    private String customerName;
    private String customerEmail;
    private String shippingAddress;
    private OrderStatus status;
    private BigDecimal totalAmount;
    private List<OrderItemResponse> items;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    public static OrderResponse fromEntity(Order order) {
        OrderResponse response = new OrderResponse();
        response.setId(order.getId());
        response.setCustomerName(order.getCustomerName());
        response.setCustomerEmail(order.getCustomerEmail());
        response.setShippingAddress(order.getShippingAddress());
        response.setStatus(order.getStatus());
        response.setTotalAmount(order.getTotalAmount());
        response.setCreatedAt(order.getCreatedAt());
        response.setUpdatedAt(order.getUpdatedAt());
        response.setItems(order.getOrderItems().stream()
                .map(OrderItemResponse::fromEntity)
                .collect(Collectors.toList()));
        return response;
    }
}

@Data
@NoArgsConstructor
@AllArgsConstructor
class OrderItemResponse {
    private Long id;
    private Long productId;
    private String productName;
    private Integer quantity;
    private BigDecimal price;
    private BigDecimal subtotal;

    public static OrderItemResponse fromEntity(OrderItem item) {
        OrderItemResponse response = new OrderItemResponse();
        response.setId(item.getId());
        response.setProductId(item.getProductId());
        response.setProductName(item.getProductName());
        response.setQuantity(item.getQuantity());
        response.setPrice(item.getPrice());
        response.setSubtotal(item.getSubtotal());
        return response;
    }
}

</order-service/src/main/java/com/ecommerce/orderservice/dto/OrderResponse.java>

<order-service/src/main/java/com/ecommerce/orderservice/dto/OrderStatusUpdateRequest.java>
package com.ecommerce.orderservice.dto;

import com.ecommerce.orderservice.model.OrderStatus;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderStatusUpdateRequest {

    @NotNull(message = "Order status is required")
    private OrderStatus status;
}

</order-service/src/main/java/com/ecommerce/orderservice/dto/OrderStatusUpdateRequest.java>

<order-service/src/main/java/com/ecommerce/orderservice/dto/ReserveStockRequest.java>
package com.ecommerce.orderservice.dto;

public class ReserveStockRequest {

    private Long productId;
    private Integer quantity;

    public ReserveStockRequest() {}

    public ReserveStockRequest(Long productId, Integer quantity) {
        this.productId = productId;
        this.quantity = quantity;
    }

    public Long getProductId() { return productId; }
    public Integer getQuantity() { return quantity; }

    public void setProductId(Long productId) { this.productId = productId; }
    public void setQuantity(Integer quantity) { this.quantity = quantity; }
}

</order-service/src/main/java/com/ecommerce/orderservice/dto/ReserveStockRequest.java>

<order-service/src/main/java/com/ecommerce/orderservice/exception/GlobalExceptionHandler.java>
package com.ecommerce.orderservice.exception;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    @ExceptionHandler(OrderNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleOrderNotFound(OrderNotFoundException ex) {
        logger.error("Order not found: {}", ex.getMessage());
        ErrorResponse error = new ErrorResponse(
                HttpStatus.NOT_FOUND.value(),
                ex.getMessage(),
                LocalDateTime.now()
        );
        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(ProductNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleProductNotFound(ProductNotFoundException ex) {
        logger.error("Product not found: {}", ex.getMessage());
        ErrorResponse error = new ErrorResponse(
                HttpStatus.NOT_FOUND.value(),
                ex.getMessage(),
                LocalDateTime.now()
        );
        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(InsufficientStockException.class)
    public ResponseEntity<ErrorResponse> handleInsufficientStock(InsufficientStockException ex) {
        logger.error("Insufficient stock: {}", ex.getMessage());
        ErrorResponse error = new ErrorResponse(
                HttpStatus.BAD_REQUEST.value(),
                ex.getMessage(),
                LocalDateTime.now()
        );
        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(InvalidOrderStatusException.class)
    public ResponseEntity<ErrorResponse> handleInvalidOrderStatus(InvalidOrderStatusException ex) {
        logger.error("Invalid order status transition: {}", ex.getMessage());
        ErrorResponse error = new ErrorResponse(
                HttpStatus.BAD_REQUEST.value(),
                ex.getMessage(),
                LocalDateTime.now()
        );
        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ValidationErrorResponse> handleValidationErrors(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach(error -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });
        
        ValidationErrorResponse errorResponse = new ValidationErrorResponse(
                HttpStatus.BAD_REQUEST.value(),
                "Validation failed",
                errors,
                LocalDateTime.now()
        );
        logger.error("Validation errors: {}", errors);
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {
        logger.error("Unexpected error occurred: ", ex);
        ErrorResponse error = new ErrorResponse(
                HttpStatus.INTERNAL_SERVER_ERROR.value(),
                "An unexpected error occurred: " + ex.getMessage(),
                LocalDateTime.now()
        );
        return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}

class ErrorResponse {
    private int status;
    private String message;
    private LocalDateTime timestamp;

    public ErrorResponse(int status, String message, LocalDateTime timestamp) {
        this.status = status;
        this.message = message;
        this.timestamp = timestamp;
    }

    public int getStatus() { return status; }
    public void setStatus(int status) { this.status = status; }
    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }
    public LocalDateTime getTimestamp() { return timestamp; }
    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }
}

class ValidationErrorResponse {
    private int status;
    private String message;
    private Map<String, String> errors;
    private LocalDateTime timestamp;

    public ValidationErrorResponse(int status, String message, Map<String, String> errors, LocalDateTime timestamp) {
        this.status = status;
        this.message = message;
        this.errors = errors;
        this.timestamp = timestamp;
    }

    public int getStatus() { return status; }
    public void setStatus(int status) { this.status = status; }
    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }
    public Map<String, String> getErrors() { return errors; }
    public void setErrors(Map<String, String> errors) { this.errors = errors; }
    public LocalDateTime getTimestamp() { return timestamp; }
    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }
}

</order-service/src/main/java/com/ecommerce/orderservice/exception/GlobalExceptionHandler.java>

<order-service/src/main/java/com/ecommerce/orderservice/exception/InsufficientStockException.java>
package com.ecommerce.orderservice.exception;

public class InsufficientStockException extends RuntimeException {
    public InsufficientStockException(String message) {
        super(message);
    }
}

</order-service/src/main/java/com/ecommerce/orderservice/exception/InsufficientStockException.java>

<order-service/src/main/java/com/ecommerce/orderservice/exception/InvalidOrderStatusException.java>
package com.ecommerce.orderservice.exception;

public class InvalidOrderStatusException extends RuntimeException {
    public InvalidOrderStatusException(String message) {
        super(message);
    }
}

</order-service/src/main/java/com/ecommerce/orderservice/exception/InvalidOrderStatusException.java>

<order-service/src/main/java/com/ecommerce/orderservice/exception/OrderNotFoundException.java>
package com.ecommerce.orderservice.exception;

public class OrderNotFoundException extends RuntimeException {
    public OrderNotFoundException(String message) {
        super(message);
    }
}

</order-service/src/main/java/com/ecommerce/orderservice/exception/OrderNotFoundException.java>

<order-service/src/main/java/com/ecommerce/orderservice/exception/ProductNotFoundException.java>
package com.ecommerce.orderservice.exception;

public class ProductNotFoundException extends RuntimeException {
    public ProductNotFoundException(String message) {
        super(message);
    }
}

</order-service/src/main/java/com/ecommerce/orderservice/exception/ProductNotFoundException.java>

<order-service/src/main/java/com/ecommerce/orderservice/model/Order.java>
package com.ecommerce.orderservice.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "orders")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Order {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String customerName;

    @Column(nullable = false)
    private String customerEmail;

    @Column(nullable = false)
    private String shippingAddress;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private OrderStatus status = OrderStatus.PENDING;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal totalAmount = BigDecimal.ZERO;

    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.EAGER)
    private List<OrderItem> orderItems = new ArrayList<>();

    @CreationTimestamp
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(nullable = false)
    private LocalDateTime updatedAt;

    public void addOrderItem(OrderItem item) {
        orderItems.add(item);
        item.setOrder(this);
    }

    public void calculateTotalAmount() {
        this.totalAmount = orderItems.stream()
                .map(OrderItem::getSubtotal)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
}

</order-service/src/main/java/com/ecommerce/orderservice/model/Order.java>

<order-service/src/main/java/com/ecommerce/orderservice/model/OrderItem.java>
package com.ecommerce.orderservice.model;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@Entity
@Table(name = "order_items")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderItem {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private Long productId;

    @Column(nullable = false)
    private String productName;

    @Column(nullable = false)
    private Integer quantity;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal price;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal subtotal;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id", nullable = false)
    @JsonIgnore
    private Order order;

    public void calculateSubtotal() {
        this.subtotal = this.price.multiply(BigDecimal.valueOf(this.quantity));
    }
}

</order-service/src/main/java/com/ecommerce/orderservice/model/OrderItem.java>

<order-service/src/main/java/com/ecommerce/orderservice/model/OrderStatus.java>
package com.ecommerce.orderservice.model;

public enum OrderStatus {
    PENDING,
    CONFIRMED,
    SHIPPED,
    DELIVERED,
    CANCELLED
}

</order-service/src/main/java/com/ecommerce/orderservice/model/OrderStatus.java>

<order-service/src/main/java/com/ecommerce/orderservice/OrderServiceApplication.java>
package com.ecommerce.orderservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class OrderServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(OrderServiceApplication.class, args);
    }
}

</order-service/src/main/java/com/ecommerce/orderservice/OrderServiceApplication.java>

<order-service/src/main/java/com/ecommerce/orderservice/repository/OrderRepository.java>
package com.ecommerce.orderservice.repository;

import com.ecommerce.orderservice.model.Order;
import com.ecommerce.orderservice.model.OrderStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
    List<Order> findByStatus(OrderStatus status);
    List<Order> findByCustomerEmail(String customerEmail);
}

</order-service/src/main/java/com/ecommerce/orderservice/repository/OrderRepository.java>

<order-service/src/main/java/com/ecommerce/orderservice/service/OrderMessageConsumer.java>
package com.ecommerce.orderservice.service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Service;

import java.util.Map;

@Service
public class OrderMessageConsumer {

    private static final Logger logger = LoggerFactory.getLogger(OrderMessageConsumer.class);

    @RabbitListener(queues = "${rabbitmq.queue.order}")
    public void consumeOrderMessage(Map<String, Object> orderEvent) {
        logger.info("Received order event from queue");
        logger.info("Order ID: {}", orderEvent.get("orderId"));
        logger.info("Customer Email: {}", orderEvent.get("customerEmail"));
        logger.info("Status: {}", orderEvent.get("status"));
        logger.info("Total Amount: {}", orderEvent.get("totalAmount"));
        logger.info("Order processing completed successfully");
    }
}

</order-service/src/main/java/com/ecommerce/orderservice/service/OrderMessageConsumer.java>

<order-service/src/main/java/com/ecommerce/orderservice/service/OrderService.java>
package com.ecommerce.orderservice.service;

import com.ecommerce.orderservice.dto.OrderItemRequest;
import com.ecommerce.orderservice.dto.OrderRequest;
import com.ecommerce.orderservice.dto.OrderResponse;
import com.ecommerce.orderservice.dto.ReserveStockRequest;
import com.ecommerce.orderservice.exception.InsufficientStockException;
import com.ecommerce.orderservice.exception.InvalidOrderStatusException;
import com.ecommerce.orderservice.exception.OrderNotFoundException;
import com.ecommerce.orderservice.exception.ProductNotFoundException;
import com.ecommerce.orderservice.model.Order;
import com.ecommerce.orderservice.model.OrderItem;
import com.ecommerce.orderservice.model.OrderStatus;
import com.ecommerce.orderservice.repository.OrderRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.client.RestTemplate;

import java.math.BigDecimal;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Service
public class OrderService {

    private static final Logger logger = LoggerFactory.getLogger(OrderService.class);

    @Autowired
    private OrderRepository orderRepository;

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Autowired
    private RestTemplate restTemplate;

    @Value("${rabbitmq.exchange.order}")
    private String orderExchange;

    @Value("${inventory.url}")
    private String inventoryUrl;

    @Value("${rabbitmq.routing.key.order}")
    private String orderRoutingKey;

    @Value("${inventory.service.url}")
    private String inventoryServiceUrl;

    @Transactional
    public OrderResponse createOrder(OrderRequest request) {
        logger.info("Creating order for customer: {}", request.getCustomerEmail());

        Order order = new Order();
        order.setCustomerName(request.getCustomerName());
        order.setCustomerEmail(request.getCustomerEmail());
        order.setShippingAddress(request.getShippingAddress());
        order.setStatus(OrderStatus.PENDING);

        for (OrderItemRequest itemRequest : request.getItems()) {
            Map<String, Object> product = getProductDetails(itemRequest.getProductId());
            
            if (product == null) {
                throw new ProductNotFoundException("Product not found with ID: " + itemRequest.getProductId());
            }

            Integer availableStock = (Integer) product.get("stockQuantity");
            if (availableStock < itemRequest.getQuantity()) {
                throw new InsufficientStockException(
                    "Insufficient stock for product: " + product.get("name") + 
                    ". Available: " + availableStock + ", Requested: " + itemRequest.getQuantity()
                );
            }

            OrderItem orderItem = new OrderItem();
            orderItem.setProductId(itemRequest.getProductId());
            orderItem.setProductName((String) product.get("name"));
            orderItem.setQuantity(itemRequest.getQuantity());
            orderItem.setPrice(new BigDecimal(product.get("price").toString()));
            orderItem.calculateSubtotal();
            
            order.addOrderItem(orderItem);
            ReserveStockRequest reserve = new ReserveStockRequest(
                    itemRequest.getProductId(),
                    itemRequest.getQuantity()
            );

            restTemplate.postForObject(
                    inventoryUrl + "/api/inventory/reserve-stock",
                    reserve,
                    String.class
            );
        }

        order.calculateTotalAmount();
        Order savedOrder = orderRepository.save(order);

        publishOrderEvent(savedOrder);

        logger.info("Order created successfully with ID: {}", savedOrder.getId());
        return OrderResponse.fromEntity(savedOrder);
    }

    public OrderResponse getOrderById(Long id) {
        logger.info("Fetching order with ID: {}", id);
        Order order = orderRepository.findById(id)
                .orElseThrow(() -> new OrderNotFoundException("Order not found with ID: " + id));
        return OrderResponse.fromEntity(order);
    }

    public List<OrderResponse> getAllOrders() {
        logger.info("Fetching all orders");
        return orderRepository.findAll().stream()
                .map(OrderResponse::fromEntity)
                .collect(Collectors.toList());
    }

    public List<OrderResponse> getOrdersByStatus(OrderStatus status) {
        logger.info("Fetching orders with status: {}", status);
        return orderRepository.findByStatus(status).stream()
                .map(OrderResponse::fromEntity)
                .collect(Collectors.toList());
    }

    public List<OrderResponse> getOrdersByEmail(String email) {
        logger.info("Fetching orders for email: {}", email);
        return orderRepository.findByCustomerEmail(email).stream()
                .map(OrderResponse::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional
    public OrderResponse updateOrderStatus(Long id, OrderStatus newStatus) {
        logger.info("Updating order {} status to: {}", id, newStatus);

        Order order = orderRepository.findById(id)
                .orElseThrow(() -> new OrderNotFoundException("Order not found with ID: " + id));

        validateStatusTransition(order.getStatus(), newStatus);

        order.setStatus(newStatus);
        Order updatedOrder = orderRepository.save(order);

        logger.info("Order status updated successfully for order ID: {}", id);
        return OrderResponse.fromEntity(updatedOrder);
    }

    private void validateStatusTransition(OrderStatus currentStatus, OrderStatus newStatus) {
        if (currentStatus == OrderStatus.DELIVERED || currentStatus == OrderStatus.CANCELLED) {
            throw new InvalidOrderStatusException(
                "Cannot update status for orders in " + currentStatus + " state"
            );
        }

        int currentOrder = getStatusOrder(currentStatus);
        int newOrder = getStatusOrder(newStatus);

        if (newStatus != OrderStatus.CANCELLED && newOrder < currentOrder) {
            throw new InvalidOrderStatusException(
                "Invalid status transition from " + currentStatus + " to " + newStatus
            );
        }
    }

    private int getStatusOrder(OrderStatus status) {
        return switch (status) {
            case PENDING -> 1;
            case CONFIRMED -> 2;
            case SHIPPED -> 3;
            case DELIVERED -> 4;
            case CANCELLED -> 5;
        };
    }

    private Map<String, Object> getProductDetails(Long productId) {
        try {
            String url = inventoryServiceUrl + "/products/" + productId;
            logger.info("Fetching product details from: {}", url);
            return restTemplate.getForObject(url, Map.class);
        } catch (Exception e) {
            logger.error("Error fetching product details: ", e);
            return null;
        }
    }

    private void publishOrderEvent(Order order) {
        try {
            Map<String, Object> orderEvent = new HashMap<>();
            orderEvent.put("orderId", order.getId());
            orderEvent.put("customerEmail", order.getCustomerEmail());
            orderEvent.put("status", order.getStatus().toString());
            orderEvent.put("totalAmount", order.getTotalAmount());
            
            List<Map<String, Object>> items = order.getOrderItems().stream()
                .map(item -> {
                    Map<String, Object> itemMap = new HashMap<>();
                    itemMap.put("productId", item.getProductId());
                    itemMap.put("quantity", item.getQuantity());
                    return itemMap;
                })
                .collect(Collectors.toList());
            
            orderEvent.put("items", items);
            
            rabbitTemplate.convertAndSend(orderExchange, orderRoutingKey, orderEvent);
            logger.info("Order event published for order ID: {}", order.getId());
        } catch (Exception e) {
            logger.error("Error publishing order event: ", e);
        }
    }
}

</order-service/src/main/java/com/ecommerce/orderservice/service/OrderService.java>

<postman-collection.json>
{
  "info": {
    "name": "E-Commerce Order Management System",
    "description": "Complete API collection for Inventory and Order microservices",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
  },
  "item": [
    {
      "name": "Inventory Service",
      "item": [
        {
          "name": "Create Product",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"sku\": \"LAPTOP-003\",\n  \"name\": \"HP Spectre x360\",\n  \"description\": \"Convertible laptop with 13.5-inch touchscreen\",\n  \"price\": 1499.99,\n  \"stockQuantity\": 40,\n  \"active\": true\n}"
            },
            "url": {
              "raw": "http://localhost:8000/api/inventory/products",
              "protocol": "http",
              "host": ["localhost"],
              "port": "8000",
              "path": ["api", "inventory", "products"]
            }
          }
        },
        {
          "name": "Get All Products",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "http://localhost:8000/api/inventory/products",
              "protocol": "http",
              "host": ["localhost"],
              "port": "8000",
              "path": ["api", "inventory", "products"]
            }
          }
        },
        {
          "name": "Get Product by ID",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "http://localhost:8000/api/inventory/products/1",
              "protocol": "http",
              "host": ["localhost"],
              "port": "8000",
              "path": ["api", "inventory", "products", "1"]
            }
          }
        },
        {
          "name": "Get Active Products",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "http://localhost:8000/api/inventory/products/active",
              "protocol": "http",
              "host": ["localhost"],
              "port": "8000",
              "path": ["api", "inventory", "products", "active"]
            }
          }
        },
        {
          "name": "Update Product",
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"sku\": \"LAPTOP-003\",\n  \"name\": \"HP Spectre x360 Updated\",\n  \"description\": \"Premium convertible laptop\",\n  \"price\": 1599.99,\n  \"stockQuantity\": 45,\n  \"active\": true\n}"
            },
            "url": {
              "raw": "http://localhost:8000/api/inventory/products/1",
              "protocol": "http",
              "host": ["localhost"],
              "port": "8000",
              "path": ["api", "inventory", "products", "1"]
            }
          }
        },
        {
          "name": "Add Stock",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"quantity\": 50\n}"
            },
            "url": {
              "raw": "http://localhost:8000/api/inventory/products/1/add-stock",
              "protocol": "http",
              "host": ["localhost"],
              "port": "8000",
              "path": ["api", "inventory", "products", "1", "add-stock"]
            }
          }
        },
        {
          "name": "Reduce Stock",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"quantity\": 10\n}"
            },
            "url": {
              "raw": "http://localhost:8000/api/inventory/products/1/reduce-stock",
              "protocol": "http",
              "host": ["localhost"],
              "port": "8000",
              "path": ["api", "inventory", "products", "1", "reduce-stock"]
            }
          }
        },
        {
          "name": "Check Stock Availability",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "http://localhost:8000/api/inventory/products/1/check-stock?quantity=5",
              "protocol": "http",
              "host": ["localhost"],
              "port": "8000",
              "path": ["api", "inventory", "products", "1", "check-stock"],
              "query": [
                {
                  "key": "quantity",
                  "value": "5"
                }
              ]
            }
          }
        },
        {
          "name": "Delete Product",
          "request": {
            "method": "DELETE",
            "header": [],
            "url": {
              "raw": "http://localhost:8000/api/inventory/products/1",
              "protocol": "http",
              "host": ["localhost"],
              "port": "8000",
              "path": ["api", "inventory", "products", "1"]
            }
          }
        }
      ]
    },
    {
      "name": "Order Service",
      "item": [
        {
          "name": "Create Order",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"customerName\": \"John Doe\",\n  \"customerEmail\": \"john.doe@example.com\",\n  \"shippingAddress\": \"123 Main Street, New York, NY 10001\",\n  \"items\": [\n    {\n      \"productId\": 1,\n      \"quantity\": 2\n    },\n    {\n      \"productId\": 2,\n      \"quantity\": 1\n    }\n  ]\n}"
            },
            "url": {
              "raw": "http://localhost:8080/api/orders",
              "protocol": "http",
              "host": ["localhost"],
              "port": "8080",
              "path": ["api", "orders"]
            }
          }
        },
        {
          "name": "Get All Orders",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "http://localhost:8080/api/orders",
              "protocol": "http",
              "host": ["localhost"],
              "port": "8080",
              "path": ["api", "orders"]
            }
          }
        },
        {
          "name": "Get Order by ID",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "http://localhost:8080/api/orders/1",
              "protocol": "http",
              "host": ["localhost"],
              "port": "8080",
              "path": ["api", "orders", "1"]
            }
          }
        },
        {
          "name": "Get Orders by Status - PENDING",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "http://localhost:8080/api/orders/status/PENDING",
              "protocol": "http",
              "host": ["localhost"],
              "port": "8080",
              "path": ["api", "orders", "status", "PENDING"]
            }
          }
        },
        {
          "name": "Get Orders by Status - SHIPPED",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "http://localhost:8080/api/orders/status/SHIPPED",
              "protocol": "http",
              "host": ["localhost"],
              "port": "8080",
              "path": ["api", "orders", "status", "SHIPPED"]
            }
          }
        },
        {
          "name": "Get Orders by Customer Email",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "http://localhost:8080/api/orders/customer/john.doe@example.com",
              "protocol": "http",
              "host": ["localhost"],
              "port": "8080",
              "path": ["api", "orders", "customer", "john.doe@example.com"]
            }
          }
        },
        {
          "name": "Update Order Status to CONFIRMED",
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"status\": \"CONFIRMED\"\n}"
            },
            "url": {
              "raw": "http://localhost:8080/api/orders/1/status",
              "protocol": "http",
              "host": ["localhost"],
              "port": "8080",
              "path": ["api", "orders", "1", "status"]
            }
          }
        },
        {
          "name": "Update Order Status to SHIPPED",
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"status\": \"SHIPPED\"\n}"
            },
            "url": {
              "raw": "http://localhost:8080/api/orders/1/status",
              "protocol": "http",
              "host": ["localhost"],
              "port": "8080",
              "path": ["api", "orders", "1", "status"]
            }
          }
        },
        {
          "name": "Update Order Status to DELIVERED",
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"status\": \"DELIVERED\"\n}"
            },
            "url": {
              "raw": "http://localhost:8080/api/orders/1/status",
              "protocol": "http",
              "host": ["localhost"],
              "port": "8080",
              "path": ["api", "orders", "1", "status"]
            }
          }
        }
      ]
    }
  ],
  "variable": [
    {
      "key": "inventory_base_url",
      "value": "http://localhost:8000/api/inventory",
      "type": "string"
    },
    {
      "key": "order_base_url",
      "value": "http://localhost:8080/api/orders",
      "type": "string"
    }
  ]
}

</postman-collection.json>

<README.md>
# E-Commerce Order Management System - Microservices

A scalable microservices-based Order Management System built with Spring Boot, featuring asynchronous processing, comprehensive API documentation, and production-ready error handling.

## Architecture Overview

This system consists of two independent microservices:

### 1. **Inventory Service** (Port 8000)
- Product management with CRUD operations
- Stock control with pessimistic locking to prevent race conditions
- Real-time inventory tracking and validation

### 2. **Order Service** (Port 8080)
- Order placement with automated inventory validation
- Order status management with state transition validation
- Integration with Inventory Service for stock verification

## Technology Stack

- **Framework**: Spring Boot 3.2.0
- **Language**: Java 17
- **Database**: PostgreSQL (NeonDB)
- **Message Queue**: RabbitMQ (async processing)
- **API Documentation**: Swagger/OpenAPI 3.0
- **Build Tool**: Maven
- **ORM**: Hibernate/JPA

## Key Features

### Functional Requirements
 Order placement with inventory validation  
 Automatic stock reduction on order confirmation  
 Order status tracking (Pending  Confirmed  Shipped  Delivered)  
 Product inventory management  
 Race condition handling with pessimistic locking  
 RESTful API design  

### Non-Functional Requirements
 Comprehensive error handling with meaningful HTTP status codes  
 Logging framework (SLF4J/Logback) for all operations  
 Swagger UI for interactive API testing  
 Async message processing with RabbitMQ  
 Database transactions for data consistency  
 Input validation with detailed error messages  

## Getting Started

### Prerequisites
- Java 17 or higher
- Maven 3.6+
- PostgreSQL database
- RabbitMQ (optional, for async features)

### Environment Variables
The following environment variables are required:
```bash
# Database Configuration
PGHOST=your-database-host
PGPORT=5432
PGDATABASE=your-database-name
PGUSER=your-database-user
PGPASSWORD=your-database-password

# RabbitMQ Configuration (Optional)
RABBITMQ_HOST=localhost
RABBITMQ_PORT=5672
RABBITMQ_USERNAME=guest
RABBITMQ_PASSWORD=guest
```

### Build and Run

#### Build Both Services
```bash
# Build Inventory Service
cd inventory-service
mvn clean package -DskipTests

# Build Order Service
cd ../order-service
mvn clean package -DskipTests
```

#### Run Services
```bash
# Run Inventory Service (Terminal 1)
cd inventory-service
java -jar target/inventory-service-1.0.0.jar

# Run Order Service (Terminal 2)
cd order-service
java -jar target/order-service-1.0.0.jar
```

## API Documentation

### Inventory Service APIs

**Base URL**: `http://localhost:8000/api/inventory`

#### Product Management

**Create Product**
```http
POST /products
Content-Type: application/json

{
  "sku": "PROD-001",
  "name": "Wireless Mouse",
  "description": "Ergonomic wireless mouse with USB receiver",
  "price": 29.99,
  "stockQuantity": 100,
  "active": true
}
```

**Get All Products**
```http
GET /products
```

**Get Product by ID**
```http
GET /products/{id}
```

**Update Product**
```http
PUT /products/{id}
Content-Type: application/json

{
  "sku": "PROD-001",
  "name": "Wireless Mouse Pro",
  "description": "Updated description",
  "price": 34.99,
  "stockQuantity": 150,
  "active": true
}
```

**Delete Product**
```http
DELETE /products/{id}
```

#### Stock Management

**Add Stock**
```http
POST /products/{id}/add-stock
Content-Type: application/json

{
  "quantity": 50
}
```

**Reduce Stock**
```http
POST /products/{id}/reduce-stock
Content-Type: application/json

{
  "quantity": 10
}
```

**Check Stock Availability**
```http
GET /products/{id}/check-stock?quantity=5
```

### Order Service APIs

**Base URL**: `http://localhost:8080/api/orders`

#### Order Management

**Create Order**
```http
POST /
Content-Type: application/json

{
  "customerName": "John Doe",
  "customerEmail": "john.doe@example.com",
  "shippingAddress": "123 Main St, New York, NY 10001",
  "items": [
    {
      "productId": 1,
      "quantity": 2
    },
    {
      "productId": 2,
      "quantity": 1
    }
  ]
}
```

**Get All Orders**
```http
GET /
```

**Get Order by ID**
```http
GET /{id}
```

**Get Orders by Status**
```http
GET /status/{status}

# Valid statuses: PENDING, CONFIRMED, SHIPPED, DELIVERED, CANCELLED
```

**Get Orders by Customer Email**
```http
GET /customer/{email}
```

**Update Order Status**
```http
PUT /{id}/status
Content-Type: application/json

{
  "status": "SHIPPED"
}
```

## Swagger UI

Access interactive API documentation:

- **Inventory Service**: http://localhost:8000/swagger-ui.html
- **Order Service**: http://localhost:8080/swagger-ui.html

## Database Schema

### Products Table (Inventory Service)
```sql
CREATE TABLE products (
    id BIGSERIAL PRIMARY KEY,
    sku VARCHAR(255) NOT NULL UNIQUE,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    price NUMERIC(10,2) NOT NULL,
    stock_quantity INTEGER NOT NULL DEFAULT 0,
    active BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL,
    version BIGINT
);
```

### Orders Table (Order Service)
```sql
CREATE TABLE orders (
    id BIGSERIAL PRIMARY KEY,
    customer_name VARCHAR(255) NOT NULL,
    customer_email VARCHAR(255) NOT NULL,
    shipping_address VARCHAR(255) NOT NULL,
    status VARCHAR(50) NOT NULL CHECK (status IN ('PENDING','CONFIRMED','SHIPPED','DELIVERED','CANCELLED')),
    total_amount NUMERIC(10,2) NOT NULL,
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL
);

CREATE TABLE order_items (
    id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL REFERENCES orders(id),
    product_id BIGINT NOT NULL,
    product_name VARCHAR(255) NOT NULL,
    quantity INTEGER NOT NULL,
    price NUMERIC(10,2) NOT NULL,
    subtotal NUMERIC(10,2) NOT NULL
);
```

## Error Handling

The system implements comprehensive error handling with appropriate HTTP status codes:

| Status Code | Description |
|------------|-------------|
| 200 OK | Successful request |
| 201 Created | Resource created successfully |
| 400 Bad Request | Validation error or invalid request |
| 404 Not Found | Resource not found |
| 409 Conflict | Duplicate resource (e.g., SKU already exists) |
| 500 Internal Server Error | Unexpected server error |

### Error Response Format
```json
{
  "status": 400,
  "message": "Validation failed",
  "errors": {
    "customerName": "Customer name is required",
    "customerEmail": "Invalid email format"
  },
  "timestamp": "2025-11-19T06:00:00"
}
```

## AWS Deployment Guide

### Deployment Architecture

```

                     AWS Cloud                            
                                                          
                        
     EC2 (t2.micro)       RDS PostgreSQL            
              (Free Tier)                
     Order                          
     Service                                        
     (8080)                           
                                           
                                                        
                                           
    Inventory                                        
     Service                                         
     (8000)                                          
                                           
                                                        
                                           
     RabbitMQ                                        
     (Docker)                                        
                                           
                                         

```

### Step-by-Step Deployment

#### 1. Setup EC2 Instance (Free Tier)
```bash
# Launch EC2 t2.micro instance with Ubuntu 22.04
# Configure Security Group:
# - Port 22 (SSH)
# - Port 8000 (Inventory Service)
# - Port 8080 (Order Service)
# - Port 5672 (RabbitMQ)

# Connect to EC2
ssh -i your-key.pem ubuntu@your-ec2-ip
```

#### 2. Install Java and Maven
```bash
sudo apt update
sudo apt install openjdk-17-jdk maven git -y
java -version
mvn -version
```

#### 3. Install Docker and RabbitMQ
```bash
# Install Docker
sudo apt install docker.io -y
sudo systemctl start docker
sudo systemctl enable docker
sudo usermod -aG docker ubuntu

# Run RabbitMQ
docker run -d --name rabbitmq \
  -p 5672:5672 \
  -p 15672:15672 \
  rabbitmq:3-management
```

#### 4. Setup RDS PostgreSQL (Free Tier)
```
# In AWS Console:
# 1. Create RDS PostgreSQL instance (db.t3.micro or db.t4g.micro for free tier)
# 2. Select "Free tier" template
# 3. Note down: endpoint, port, username, password, database name
# 4. Configure security group to allow connections from EC2
```

#### 5. Clone and Build
```bash
# Clone repository
git clone <your-repo-url>
cd order-management-system

# Set environment variables
export PGHOST=your-rds-endpoint
export PGPORT=5432
export PGDATABASE=your-database-name
export PGUSER=your-username
export PGPASSWORD=your-password
export RABBITMQ_HOST=localhost

# Build services
cd inventory-service && mvn clean package -DskipTests
cd ../order-service && mvn clean package -DskipTests
```

#### 6. Run Services with systemd

**Inventory Service systemd unit** (`/etc/systemd/system/inventory-service.service`):
```ini
[Unit]
Description=Inventory Service
After=network.target

[Service]
User=ubuntu
WorkingDirectory=/home/ubuntu/order-management-system/inventory-service
Environment="PGHOST=your-rds-endpoint"
Environment="PGPORT=5432"
Environment="PGDATABASE=your-database"
Environment="PGUSER=your-user"
Environment="PGPASSWORD=your-password"
Environment="RABBITMQ_HOST=localhost"
ExecStart=/usr/bin/java -jar target/inventory-service-1.0.0.jar
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
```

**Order Service systemd unit** (`/etc/systemd/system/order-service.service`):
```ini
[Unit]
Description=Order Service
After=network.target

[Service]
User=ubuntu
WorkingDirectory=/home/ubuntu/order-management-system/order-service
Environment="PGHOST=your-rds-endpoint"
Environment="PGPORT=5432"
Environment="PGDATABASE=your-database"
Environment="PGUSER=your-user"
Environment="PGPASSWORD=your-password"
Environment="RABBITMQ_HOST=localhost"
ExecStart=/usr/bin/java -jar target/order-service-1.0.0.jar
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
```

**Start services**:
```bash
sudo systemctl daemon-reload
sudo systemctl start inventory-service
sudo systemctl start order-service
sudo systemctl enable inventory-service
sudo systemctl enable order-service

# Check status
sudo systemctl status inventory-service
sudo systemctl status order-service
```

#### 7. Setup Nginx Reverse Proxy (Optional)
```bash
sudo apt install nginx -y

# Configure /etc/nginx/sites-available/default
server {
    listen 80;
    server_name your-domain.com;

    location /api/inventory {
        proxy_pass http://localhost:8000/api/inventory;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }

    location /api/orders {
        proxy_pass http://localhost:8080/api/orders;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}

sudo nginx -t
sudo systemctl restart nginx
```

### Cost Estimation (Free Tier)
- **EC2 t2.micro**: 750 hours/month free
- **RDS db.t3.micro**: 750 hours/month free
- **Data Transfer**: 15GB/month free
- **Total**: $0/month within free tier limits

## Testing

### Sample Testing Flow

1. **Create Products**
```bash
curl -X POST http://localhost:8000/api/inventory/products \
  -H "Content-Type: application/json" \
  -d '{
    "sku": "LAPTOP-001",
    "name": "MacBook Pro",
    "description": "16-inch MacBook Pro",
    "price": 2499.99,
    "stockQuantity": 50
  }'
```

2. **Create Order**
```bash
curl -X POST http://localhost:8080/api/orders \
  -H "Content-Type: application/json" \
  -d '{
    "customerName": "Jane Smith",
    "customerEmail": "jane@example.com",
    "shippingAddress": "456 Oak Ave, Boston, MA 02101",
    "items": [
      {"productId": 1, "quantity": 1}
    ]
  }'
```

3. **Update Order Status**
```bash
curl -X PUT http://localhost:8080/api/orders/1/status \
  -H "Content-Type: application/json" \
  -d '{"status": "SHIPPED"}'
```

## Project Structure

```
order-management-system/
 inventory-service/
    src/main/java/com/ecommerce/inventoryservice/
       controller/      # REST controllers
       service/         # Business logic
       repository/      # Data access layer
       model/           # JPA entities
       dto/             # Data transfer objects
       config/          # Configuration classes
       exception/       # Exception handlers
    src/main/resources/
       application.properties
    pom.xml
 order-service/
    src/main/java/com/ecommerce/orderservice/
       controller/      # REST controllers
       service/         # Business logic
       repository/      # Data access layer
       model/           # JPA entities
       dto/             # Data transfer objects
       config/          # Configuration classes
       exception/       # Exception handlers
    src/main/resources/
       application.properties
    pom.xml
 docker-compose.yml       # RabbitMQ setup
 README.md
```

## Troubleshooting

### Common Issues

**Database Connection Failed**
- Verify environment variables are set correctly
- Check PostgreSQL is running and accessible
- Ensure database user has proper permissions

**RabbitMQ Connection Warnings**
- Non-critical if you're not using async features
- Start RabbitMQ with Docker: `docker-compose up -d`

**Port Already in Use**
- Change ports in `application.properties`
- Kill existing process: `lsof -ti:8080 | xargs kill`

## Future Enhancements

- [ ] Implement rate limiting with bucket4j
- [ ] Add Redis caching layer
- [ ] Implement retry mechanism for failed orders
- [ ] Add API Gateway with Spring Cloud Gateway
- [ ] Implement circuit breaker pattern
- [ ] Add distributed tracing with Zipkin
- [ ] Implement database read replicas
- [ ] Add comprehensive unit and integration tests

## Contact

For questions or support:
- Email: ashutosh.t@sunking.com
- Phone: 9958762772

## License

This project is developed as a case study for backend developer assessment.

</README.md>

<replit.md>
# E-Commerce Order Management System

## Overview

This is a production-ready microservices-based Order Management System built with Spring Boot that handles product inventory and order processing. The system uses asynchronous message processing for scalability and implements pessimistic locking to prevent race conditions during concurrent inventory operations. The architecture follows REST API design principles with comprehensive error handling and validation.

**Current Status**:  Fully Functional - Both services are running and tested successfully
- **Inventory Service**: Running on port 8000 with REST APIs and database integration
- **Order Service**: Running on port 8080 with REST APIs and database integration
- **Database**: PostgreSQL (NeonDB) connected and tables created
- **APIs Tested**: Product creation and order placement working correctly

## User Preferences

Preferred communication style: Simple, everyday language.

## System Architecture

### Microservices Design

**Problem**: Need to build a scalable e-commerce system that can handle inventory and orders independently.

**Solution**: Two independent microservices architecture:
- **Inventory Service** (Port 8000): Manages products and stock levels
- **Order Service** (Port 8080): Handles order placement and status tracking

**Rationale**: Separation allows independent scaling, deployment, and development of inventory vs order functionality. Each service can have its own database and scaling strategy.

### Technology Choices

**Backend Framework**: Spring Boot 3.2.0 with Java 17
- Provides robust dependency injection, transaction management, and production-ready features
- Excellent ecosystem for microservices (Spring Cloud compatibility)
- Built-in support for REST APIs, validation, and ORM

**ORM**: Hibernate/JPA
- Database-agnostic persistence layer
- Automatic schema generation and migration support
- Built-in support for pessimistic locking

### Concurrency Control

**Problem**: Prevent overselling when multiple orders try to reduce stock simultaneously.

**Solution**: Pessimistic locking on inventory updates
- Locks database rows during stock reduction operations
- Ensures sequential processing of concurrent stock updates

**Alternatives Considered**: Optimistic locking
**Pros**: Guarantees data consistency under high concurrency
**Cons**: May reduce throughput compared to optimistic locking in low-contention scenarios

### Asynchronous Processing

**Message Queue**: RabbitMQ
- Decouples order processing from inventory updates
- Enables retry mechanisms for failed operations
- Provides message persistence and delivery guarantees

**Use Case**: Order confirmation triggers async inventory reduction messages

### API Design

**Documentation**: Swagger/OpenAPI 3.0
- Interactive API testing via Swagger UI
- Auto-generated API documentation from code annotations
- Standardized API contract definition

**REST Principles**:
- Resource-based URLs (`/api/inventory/products`, `/api/orders`)
- HTTP methods for CRUD operations
- Meaningful HTTP status codes for different error scenarios
- JSON request/response format

### Order State Management

**State Transitions**: Pending  Confirmed  Shipped  Delivered
- Validates state transitions to prevent invalid status updates
- Business logic enforces sequential progression through order lifecycle

### Error Handling Strategy

**Approach**: Centralized exception handling with specific HTTP status codes
- 400 Bad Request: Validation errors
- 404 Not Found: Resource not found
- 409 Conflict: Business rule violations (e.g., insufficient stock)
- 500 Internal Server Error: Unexpected errors

**Logging**: SLF4J/Logback for structured logging across all operations

### Data Validation

**Input Validation**: Bean Validation (JSR-380)
- Validates request payloads before processing
- Returns detailed error messages with field-level information
- Prevents invalid data from entering the system

## External Dependencies

### Database
- **PostgreSQL** via NeonDB (cloud-hosted)
- Relational database for ACID compliance
- Supports pessimistic locking for concurrency control
- Each microservice has independent database schema

### Message Queue
- **RabbitMQ**: Message broker for async communication between services
- Handles order confirmation events and inventory update messages
- Provides message persistence and delivery acknowledgments

### Build & Dependencies
- **Maven**: Dependency management and build automation
- Spring Boot Starter dependencies for web, data JPA, validation, and AMQP

### API Testing
- **Postman Collection**: Pre-configured API requests for testing
- Includes examples for all inventory and order operations

### Infrastructure Requirements
- Java 17+ runtime environment
- PostgreSQL database instance
- RabbitMQ server for message queuing
- Ports 8000 (Inventory) and 8080 (Order) available
</replit.md>

